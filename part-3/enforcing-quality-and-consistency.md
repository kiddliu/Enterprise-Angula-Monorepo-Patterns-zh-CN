# 第三部分 保证质量与一致性

&emsp;&emsp;Nx包含了一些保证代码一致性与质量的工具。我们来看看：

* 强制**单版本**：只有一个package.json文件保证了所有应用与库都依赖相同版本的依赖库。
* 保证**代码格式的一致性**：类似`prettier`的构建工具可以用来确保代码格式的一致性（一个直接好处就是消除了PR中的空格与格式差异）。
* 强制库依赖关系的限制：允许配置库之间的限制从而使得`util`库没有办法依赖`feature`库（或是应用）。
* 强制**代码生成的一致性**：Nx允许生成工作区结构图（schematics），一致地处理代码生成问题。
* 强制**应用之间网络通信的一致性与可靠性**：Nx包含了DataPersistence库，以一致且可靠的方式管理与后端的交互。

## 强制单版本

&emsp;&emsp;Google强制一条限制：所有Angular项目都有一模一样的版本。这样做对他们最大的好处在于他们可以在内部测试新版本，消除问题；然而，你应该意识到除此之外还有其他好处：

* 组织内分享代码变得更简单了。由于依赖库都有同样的版本，在集成的时候不用再花精力检查先前已有代码可不可以工作了。
* 保证了不会有未修复的安全漏洞。
* 使得开发者可以在项目之间流动。

&emsp;&emsp;如果我们也在使用基于主干的开发模式的话（请参考第五部分中关于主干开发的讨论），这样做也会有些不好的地方。

* 更新依赖库版本的时候，如果改动太多，也会花更多的精力。组织内保证固定频率的更新（依赖库）可以稍稍缓解这种情况。然而，版本的大更新会导致更多的变更。
* 某个项目使用依赖库的不同版本变得不可能。这使得使用依赖库新版本构建原型时变得更困难（除非全局更新，否则这些代码没有合并的可能）。

&emsp;&emsp;单版本规则会应用于工作区的两个方面：

1. 单个package.json：如果只有一个`package.json`文件，那么其中列出的依赖项就会应用于整个工作区。
2. 所有的库代码都在同一个仓库：所有的库代码都在同一个仓库，于是除非本地与目标分支不同步，否则没有办法有库代码的先前版本。

&emsp;&emsp;针对这两个问题，我们可以：

### 单个package.json

&emsp;&emsp;可以使用Lerna或是yarn工作区，使得每个应用都有独立的package.json文件，并集中管理。因为这样做会产生大量的额外开销，Nx不支持多个package.json文件，而是假设工作区内只有一个package.json文件。

### 所有的库代码都在同一个仓库

&emsp;&emsp;可以使用git submodule来模拟库的不同版本（每个库在自己的仓库里）。使用git submodule的话Nx可以工作，但是不鼓励这样做，因为复杂度太高，而且使用SHA不匹配的submodule的可能性也大增。

&emsp;&emsp;Nx，作为一个有态度的工具，通过只包含一个package.json文件且只有一个仓库（而不使用git submodule）实践了单版本规则。

## 保证代码格式的一致性

&emsp;&emsp;在Google，一切可以自动化的东西都应该被自动化是一般原则。这其中就包括格式化代码。这也就是为什么Nx内建了对Prettier的支持。

&emsp;&emsp;它完全无需配置。只需要调用`format:write`来格式化受影响的文件，同时在CI中调用`format:check`来保证所有文件都被格式化好了。

&emsp;&emsp;运行`npm run format:write -- --help`可以查看可用的选项。

&emsp;&emsp;`npm run format:write -- --base=[SHA1] --base=[SHA2]`。Nx提供这个命令来计算两次提交之间所有的变动，并格式化受到影响的文件。比如`npm run format:write -- --base=origin/master --base=HEAD`用来格式化某个PR带来的改动。

&emsp;&emsp;`format:check`命令接受相同的参数，但它不是格式化文件，而是在任意文件没有正确格式化时抛出错误。这在CI/CD阶段相当有用。

&emsp;&emsp;使用自动化工具格式化有相当重要的好处：diff只包含了实际的代码变动。包含了空格的大型diff使得我们很难从格式化结果中分辨出实际的代码变动。如果开发者间的本地设置还不尽相同，并因此不断地提交相同的改动的话就更糟糕了。
