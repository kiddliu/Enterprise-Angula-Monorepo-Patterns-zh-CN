# 第一部分 入门

## 为什么要用单仓库？

&emsp;&emsp;许多大型组织或是组织中的部分业务单元选择在单仓库中开发他们所有的代码。这种方式有几个目标：

### 增加可见性

&emsp;&emsp;企业或是业务单元内的团队常常不是很了解其他团队在做什么，在集成阶段就会有很大的影响。如果在代码提交时就可以发现集成的问题，就可以省下大量时间。在第五部分我们会讨论应对这些变化的一些策略。

&emsp;&emsp;此外，API契约在单仓库中更容易访问，前端与后端都可以直接使用。类型可以从契约中生成，而同时被前端与后端使用保证了错误可以在编译期就被捕获，而不是在更宝贵的集成期。

### 复用代码更直接

&emsp;&emsp;模块化代码、共享代码的传统方式是创建包，部署到私有npm仓库，然后再把它添加到项目依赖中。尝试做变更会因为打包和部署这些代码产生大量开销。版本控制也是一个问题，因为我们必须使用正确的版本号。

&emsp;&emsp;程序员们在本地开发时也许会另外选择`npm link`或是类似的方式来模拟这种依赖关系，可即使是这样，搭建使用起来也很繁杂：依赖项也许会有很多，我们都需要这样设置一遍，还得记得在完成的时候去掉这些链接。

&emsp;&emsp;使用单仓库，就允许你直接引用依赖项（Nx的话可以用工作目录相对路径）。程序员们也可以直接修改这些代码，在本书的第五部分“基于trunk的开发”一节里，我们会讨论集成对共享代码的变更的一些方式。

### 保证依赖项的版本一致

&emsp;&emsp;单仓库中的版本控制更加简单——组织或是业务单元可以选择让所有的依赖项目使用同一个版本号，或是“最新的几个版本”策略，从而保证所有的项目都是最新的。这减小了代码对作废的依赖项或是有风险的版本的依赖。具体可以参考本书的第五部分“唯一版本策略”一节

所有这些目标都可以通过使用Nx实现。
