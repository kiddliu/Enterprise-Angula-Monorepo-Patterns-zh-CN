# 第一部分 入门

## 为什么要用单仓库？

&emsp;&emsp;许多大型组织或是组织中的部分业务单元选择在单仓库中开发他们所有的代码。这种方式有几个目标：

### 增加可见性

&emsp;&emsp;企业或是业务单元内的团队常常不是很了解其他团队在做什么，在集成阶段就会有很大的影响。如果在代码提交时就可以发现集成的问题，就可以省下大量时间。在第五部分我们会讨论应对这些变化的一些策略。

&emsp;&emsp;此外，API契约在单仓库中更容易访问，前端与后端都可以直接使用。类型可以从契约中生成，而同时被前端与后端使用保证了错误可以在编译期就被捕获，而不是在更宝贵的集成期。

### 复用代码更直接

&emsp;&emsp;模块化代码、共享代码的传统方式是创建包，部署到私有npm仓库，然后再把它添加到项目依赖中。尝试做变更会因为打包和部署这些代码产生大量开销。版本控制也是一个问题，因为我们必须使用正确的版本号。

&emsp;&emsp;程序员们在本地开发时也许会另外选择`npm link`或是类似的方式来模拟这种依赖关系，可即使是这样，搭建使用起来也很繁杂：依赖项也许会有很多，我们都需要这样设置一遍，还得记得在完成的时候去掉这些链接。

&emsp;&emsp;使用单仓库，就允许你直接引用依赖项（Nx的话可以用工作区相对路径）。程序员们也可以直接修改这些代码，在本书的第五部分“基于trunk的开发”一节里，我们会讨论集成对共享代码的变更的一些方式。

### 保证依赖项的版本一致

&emsp;&emsp;单仓库中的版本控制更加简单——组织或是业务单元可以选择让所有的依赖项目使用同一个版本号，或是“最新的几个版本”策略，从而保证所有的项目都是最新的。这减小了代码对作废的依赖项或是有风险的版本的依赖。具体可以参考本书的第五部分“唯一版本策略”一节

&emsp;&emsp;所有这些目标都可以通过使用Nx实现。

## 为什么要用Nx？

&emsp;&emsp;大型组织会遇到一些小型团队不会遇到的问题：

* 10名工程师可以在午饭时间通过闲聊就对最佳实践达成一致，然而500名工程师就不行了。你必须建立最佳时间，团队标准，并且使用工具推广它们。
* 当只有3个项目的时候，程序员们知道做出变更之后哪些地方需要重新测试。当有30个项目的时候，这就不再是一个简单的流程。用非正式的规则来管理变更对于大团队以及多个团队多个项目的情况是无效的。取而代之的是应当依赖自动化的持续集成流程。

&emsp;&emsp;换句话说，通常小型组织可以通过非正式的临时流程来解决问题，而这样做对于大型组织来说是不行的。大型组织只可能通过工具化来解决问题，而Nx就提供了这样的方法。它包含了以下这些东西：

* 用于生成代码，从而保证项目之间一致性的原理图（schematics）
* 用来强制代码检查以及格式化的工具
* 用来图形化代码仓库中的应用与库之间依赖关系的工具
* 用来对代码变更执行的命令：任何尚未提交的变更，任意两个git提交之间的比较，与另一个分支之间的比较，等等。这些命令可以只对那些受到影响的文件进行测试、检查，从而绕开了那些没有受到影响的文件，节省了大量的时间。
* 用来解决Angular应用之间竞争条件的工具

&emsp;&emsp;接下来，让我们来了解一些Nx的基本概念：工作区域，应用，以及库。

## Nx基本概念

### 什么是工作区

&emsp;&emsp;工作区是用Nx创建出来的文件夹。这个文件夹包含了一个git仓库，包括apps（应用）和libs（库）文件夹；还有一些用来帮助构建，代码检查以及测试的辅助工具。

### 什么是app？

&emsp;&emsp;App生成二进制文件。它包含了打包库所需的必要代码，创建出可以被部署的artifact。

&emsp;&emsp;App定义了如何构建提供给用户的artifact。如果我们分别有两个目标（比如说桌面端与移动端），我们也许需要两个不同的app。

&emsp;&emsp;在我们的参考示例中，4个应用是按照下面的方式组织的：

&emsp;&emsp;*app的文件夹树*

    apps/
        booking/
            booking-desktop/    <--- 应用
            booking-mobile/     <--- 应用
        check-in/
            check-in-desktop/   <--- 应用
            check-in-mobile/    <--- 应用

&emsp;&emsp;每个app都有对应生成的端到端测试app文件夹。

&emsp;&emsp;App只是用来把其他库组织成可以部署的artifact——除了模块文件以及一些简单的路由，app中就再没有其他代码了。所有的应用代码都被组织到了不同的库中。

### 什么是lib？

&emsp;&emsp;Lib是一组打包在一起的文件，由app使用。Lib与node模块或是nuget包类似。它们可以被发布到NPM，或是与发布的app打包在一起。

&emsp;&emsp;Lib的意义在于把代码拆分成更小的单元，从而更容易维护、提升代码复用。从Angular 6开始，库可以放在`apps`夹，直接在应用中使用，或是作为独立的包打包部署到NPM。

&emsp;&emsp;库有一组完备的公共API定义在index.ts文件里。通常还会有README文件以及指定的代码所有者（关于代码所有者详见第五部分中的讨论）。

&emsp;&emsp;一些库只用在特定的应用中（比如订票）因而应该放在合适的文件夹中（比如`libs/booking`）。我们把它们叫做“特定于（某个）应用”的库。即使这些库还可以用在其他地方，创建它们的目的不在于代码复用，而是把应用构建为定义好的多个模块，从而简化应用的维护工作。

&emsp;&emsp;典型的Nx工作区只包含4种类型的库：功能（feature）、数据访问（data-access）库，用户界面（ui）库与工具（util）库。 你可以在本书的第2部分中详细了解了这些类型的库。

## Nx的交互

&emsp;&emsp;Nx使用以下这些配置文件配置工作区：

* 特定于Nx的`nx.json`
* npm提供的`package.json`
* Angular命令行提供的`angular.json`

&emsp;&emsp;Nx也提供了针对工作区、应用以及库的命令。它们可以在命令行中执行，或是在Angular Console中调用。Angular Console是一个与Angular命令行以及Nx交互的图形化工具，我们会在附录甲中讨论它。

&emsp;&emsp;在本书中，我们在讨论命令行命令时会使用`npm`。适时也会提供Angular Console的操作。所有这些命令都被列在了附录乙中。

### `yarn`与`npm`

&emsp;&emsp;在本书中，我们使用`npm`提供示例代码。所有这些命令都可以用`yarn`完成。这二者之间有一些差异：

1. npm命令既可以为命令本身也可以为封装的命令接收参数。比如`npm run task1 --watch -- --param1=val1`把`watch`传给了npm本身，而把`param1`传给了`task1`的底层实现。`--`本身指明了在它之后的所有参数都是传给底层任务的。而`yarn`不是这样，它把所有的参数都传给底任务；所以它不需要`--`分隔符。
2. `npm`命令是用`npm run <command>`执行而`yarn`命令是用`yarn <command>`执行。
3. `npm install`安装包，你需要指明`--save`或是`--save-dev`来保存依赖关系；而`yarn`使用`yarn add`安装包并且默认添加到package.json。

&emsp;&emsp;本书中，你可以用以下方法把npm脚本转为使用yarn：

1. 如果命令是`npm run`开头的，你可以用`yarn`来替换`npm run`。否则，如果命令是`npm install`那么你可以取而代之使用`yarn add`（如果是`npm install -g`或者`npm install --global`，可以使用`yarn add global`）。剩余其他情况你都可以用`yarn`直接替换`npm`。
2. 如果命令本身包含`--`，就去掉它。

## 安装并设置工作区

&emsp;&emsp;*请访问[Getting Started](https://nx.dev/angular/getting-started/getting-started)获取最新的信息*

## 获取帮助

&emsp;&emsp;*请访问[Getting Started](https://nx.dev/angular/getting-started/getting-started)获取最新的信息*

## 小结

&emsp;&emsp;这一节为本书的其余部分打下了基础。

* 我们了解了采用单仓库思维的一些原因：为所有的团队提升了代码的可见性，直接复用代码而不是使用包管理系统发布引用包，并且在所有项目之间保证依赖版本的一致。我们会在本书的第五部分具体了解单仓库。
* 我们了解了如何使用命令行以及Angular Console创建工作区、应用以及包。
* 我们了解了两张不同的方式来获取命令的帮助：`--help`命令行选项，以及通过在Angular Console中打开项目，查看各个选项的描述。

&emsp;&emsp;有了这些基础，我们可以开始深入了解库，并且检视如何把我们的代码结构化为可组合、可重用和易于浏览的方式。
