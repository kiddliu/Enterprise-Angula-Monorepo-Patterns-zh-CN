# 第二部分 用库组织代码

## 简介

&emsp;&emsp;随着时间发展，应用无论在大小还是复杂度上都会增加，尤其是当多个应用需要共享代码的时候更加严重。于是，大型组织与业务需要考虑在大小以及复杂度上拆分应用、组件复用，从而在如何实现的角度上保持一致。

&emsp;&emsp;库，作为执行特定任务的一组相关文件，以模块化的方式对开发有帮助。在包的`index.ts`文件中包含了一组定义良好的公共API，指明如何使用这个包。开发者也应该包含一个README文件，用来记录库的行为以及指定的代码所有者（更多信息请查看第五部分的“代码所有权”一节）。

&emsp;&emsp;在Nx工作区里，库需要修饰符来描述它的内容与预期目的。这些修饰符帮助我们组织库，并提供一种可视化的区分它们的方式。这里有两种基本的修饰符：“范围”与“type”。也可以加入额外的修饰符描述特定组织内的不同场景，比如“platform”。

#### 范围

&emsp;&emsp;范围与逻辑分组、业务用例或是领域相关。我们的实例应用中的范围示例有`seatmap`、`booking`、`shared`以及`check-in`。它们各自包含了一组用来管理应用逻辑子领域（sub-domain）的包。

<hr>

&emsp;&emsp;我们推荐使用**文件夹结构来标记范围**

&emsp;&emsp;下边的文件夹结构是一个示例范围结构，用来描述座位图功能：

    shared/
        seatmap/
            feature/

&emsp;&emsp;这里，“shared”与“seatmap”都是用来分组的文件夹，而`feature`是一个嵌套两层深的库。这样做就很清晰了：这个功能是属于`shared`的子领域`seatmap`的。

&emsp;&emsp;这个库使用的标签就是`scope:shared`，这是一个顶层范围。

<hr>

#### 类型

&emsp;&emsp;类型与库的内容有关，并指明它的目的与用途。类型的示例有`ui`、`data-access`以及`feature`。具体请看下边的讨论。

<hr>

&emsp;&emsp;我们推荐使用**前缀与标记来表示类型**。我们还推荐限制类型的数量为这一节描述的那4个。

&emsp;&emsp;这个功能的文件夹名于是就是`feature-shell`，它使用了库类型作为前缀。

&emsp;&emsp;那么上一个例子中座位图功能库的标签现在就变成了`scope:shared,type:feature`。

<hr>

#### 平台

&emsp;&emsp;我们可以用其他标识符来区分类似的库（比如为了区分`server`、`mobile`以及`desktop`）。**频台**就是一种这样的标识符。

<hr>

&emsp;&emsp;我们推荐使用**标签来标记平台**。

&emsp;&emsp;座位图功能最终的标签于是变成了`scope:shared,type:feature,platform:desktop`。

<hr>

&emsp;&emsp;每一个库都应该存放在其范围定义的文件夹树中，有着类似上边的`scope:SCOPE,type:TYPE,platform:PLATFORM`格式的标签，并以它的类型为名称前缀。对于标签是如何使用的，请查看第三部分的“对库的依赖项进行强制限制”一节。

<hr>

&emsp;&emsp;*不要按文件类型分文件夹*
    
&emsp;&emsp;我们强烈不鼓励文件按类似`directives/`、`services/`这样的方式组织。原因是当我们尝试做修改的时候，我们常常需要同一时刻修改一系列相关的文件。如果按照文件类型组织，我们就会因为需要找到需要的文件而频繁遍历文件夹树。
    
&emsp;&emsp;我们更建议代码按照领域组织，把所有相关的文件，比如`airline`包含的状态、ui组件等等都放在一个文件夹内。这使得开发者可以直接工作在相关的文件上而无需频繁地遍历文件夹树。

<hr>
